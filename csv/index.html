<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0; maximum-scale=1.0; minimum-scale=1.0; user-scalable=no;" />
  <title>ìœ„í‚¤ ì‹œê°í‘œìš© CSV í¸ì§‘ê¸°</title>
  <style>
:root{
  --bg:#fafaf8; 
  --panel:#ffffff; 
  --ink:#2d2d2b; 
  --muted:#7a7a75; 
  --line:#dcdcd6; 
  --accent:#5bb6a5; /* Soft tealâ€“mint accent */
  --chip:#f4f5f3; 
  --warn:#e0a94f; 
  --bad:#e26d6d; 
  --good:#4ea87d;
  --radius:14px; 
  --gap:12px;
}

*{box-sizing:border-box;}
header {
  padding-top: 10px;
}

html,body{height:100%}
body{
  margin:0;
  background:linear-gradient(180deg,#f9fafb,#f3f4f6);
  color:var(--ink);
  font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"
}
td.removedCell{
  background: repeating-linear-gradient(135deg,#fee2e2,#fee2e2 8px,#fff 8px,#fff 16px);
  color:#9ca3af;
}
th.removedCell{
  background: repeating-linear-gradient(135deg,#fee2e2,#fee2e2 8px,#f1f5f9 8px,#f1f5f9 16px);
  color:#9ca3af;
}
.wrap{max-width:1200px;margin:20px auto;padding:0 16px}
header{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:14px}
h1{font-size:18px;margin:0;font-weight:700;letter-spacing:0.2px}
.hint{color:var(--muted);font-size:13px}
.row{display:grid;grid-template-columns: 1.15fr 1.8fr 1.05fr; gap:var(--gap)}

.card{
  background:var(--panel);
  border:1px solid var(--line);
  border-radius:var(--radius);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  min-height:220px;
}
.card h2{
font-size: 15px;
  font-weight: 700;
  margin: 0;
  border-bottom: 1px solid var(--line);
  padding: 9px 16px 8px;
  color: #334155;
}
.card .body{padding:12px;display:flex;flex-direction:column;gap:10px}
#shortcuts{overflow-y: scroll; width: 180px; padding: 8px; height: 250px;}
textarea{
  width:100%;
  min-height:160px;
  resize:vertical;
  background:#f8fafc;
  color:var(--ink);
  border:1px solid var(--line);
  border-radius:10px;
  padding:10px;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
}

button{
  appearance:none;
  border:1px solid var(--line);
  background:#f3f4f6;
  color:var(--ink);
  border-radius:10px;
  padding:8px 10px;
  font-weight:600;
  cursor:pointer;
  font-size: 13px;
}
button.primary{
  background:linear-gradient(180deg,#6bc3b1,#4ea693);
  color:#fff;
  border-color:#4ea693;
}
button:hover{filter:brightness(1.05)}

.toolbar{display:flex;gap:8px;flex-wrap:wrap}

/* Grid */
.gridwrap{overflow:auto;border:1px solid var(--line);border-radius:12px}
table{border-collapse:separate;border-spacing:0;width:max-content;min-width:100%}
td,th{
  border-right:1px solid var(--line);
  border-bottom:1px solid var(--line);
  padding:6px 8px;
  vertical-align:middle;
  text-align: center;
  min-width:60px;
  max-width:180px;
  font-size:15px;
}
tr:first-child th, tr:first-child td{border-top:1px solid var(--line)}
tr > :first-child{border-left:1px solid var(--line)}
th, .headerCell{background:#f1f5f9;color:#1e293b}

.cell{position:relative}
.cell input{width:100%;background:transparent;color:inherit;border:none;outline:none;font:inherit;padding:0;margin:0}

.chips{display:flex;gap:3px;flex-wrap:wrap;margin-top:8px;}
.chip{
  background:var(--chip);
  border:1px solid #cbd5e1;
  border-radius:999px;
  padding:2px 8px;
  font-size:11px;
  color:#334155;
  font-weight: 700;
}
.chip.warn{border-color:#f59e0b;color:#92400e;background:#fef3c7}
.chip.bad{border-color:#ef4444;color:#7f1d1d;background:#fee2e2}
.chip.good{border-color:#10b981;color:#064e3b;background:#d1fae5}
/* inline add-chip dropdown */
/* Fancy add-chip dropdown */
.chipAdd {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background: var(--bg2);
  color: var(--ink);
  font-size: 11px;
  font-weight: 500;
  padding: 3px 24px 3px 8px;
  border-radius: 999px;
  border: 1px solid var(--line);
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
  background-image: url('data:image/svg+xml;utf8,<svg fill="%23888" height="12" viewBox="0 0 20 20" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M5 7l5 5 5-5z"/></svg>');
  background-repeat: no-repeat;
  background-position: right 6px center;
  background-size: 10px 10px;
}

.chipAdd:hover {
  background: var(--bg3);
  border-color: var(--accent);
}

.chipAdd optgroup {
  font-style: normal;
  font-weight: bold;
  color: var(--ink2);
  background: var(--bg2);
}

.chipAdd option {
  background: var(--bg1);
  color: var(--ink);
}
/* Quick value buttons (v/x/i) */
.valBtns { display:inline-flex; gap:3px; margin-right:6px; }
.valBtn {
  font-size:13px; font-weight:600;
  padding:2px 8px; border-radius:999px;
  border:1px solid var(--line); background:#fff; color:var(--ink);
  cursor:pointer; transition:.15s;
  width: 30px; height: 26px;
}
.valBtn:hover { border-color:var(--accent); box-shadow:0 1px 0 rgba(0,0,0,.04) }

/* Custom add-menu */
.chipMenu { position:relative; display:inline-block; }
.chipAddBtn {
  font-size:13px; font-weight:600; line-height: 1;
  padding:6px 10px 6px 21px; border-radius:999px;
  border:1px solid var(--line); background:#fff; color:var(--ink);
  cursor:pointer; transition:.15s; position:relative;
}
.chipAddBtn::before { /* plus icon */
  content:'+'; position:absolute; left:8px; top:50%; transform:translateY(-50%);
  font-weight:800; opacity:.85;
}
.chipAddBtn::after { /* caret */
  content:''; position:absolute; right:8px; top:50%; transform:translateY(-50%);
  width:10px; height:10px;
  background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill="%23888" d="M5 7l5 5 5-5z"/></svg>');
  background-size:10px 10px; background-repeat:no-repeat;
}
.chipAddBtn:hover { border-color:var(--accent); }

.chipMenuList {
  position:absolute; z-index:50; right:0; top:calc(100% + 6px);
  min-width:210px; max-height:260px; overflow:auto;
  background:#fff; border:1px solid var(--line); border-radius:10px;
  box-shadow:0 10px 24px rgba(0,0,0,.08);
  padding:6px; display:none;
}
.chipMenuList.open { display:block; }

.menuGroupTitle {
  font-size:11px; font-weight:700; color:#475569; padding:4px 6px 6px;
}
.menuItem {
  display:flex; align-items:center; gap:8px;
  padding:8px 8px; border-radius:8px; cursor:pointer;
  font-size:13px; color:#111827;
  font-weight:600;
}
.menuItem:hover { background:#f8fafc; }
.menuIcon {
  width:20px; height:20px; border-radius:6px;
  display:flex; align-items:center; justify-content:center;
  background:#f1f5f9; color:#334155; font-weight:800; font-size:12px;
}
.menuHint { margin-left:auto; color:#64748b; font-size:11px; font-weight:400 }
.menuSep { height:1px; background:#eef2f7; margin:6px 4px; }
/* Floating inline editor */
textarea {
  font-size: 14px;
}
.ie {
  position: fixed; z-index: 10000;
  display: none; flex-direction: column; gap: 6px;
  width: min(400px, calc(100vw - 24px));
  background: #fff; color: var(--ink);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 8px;
  box-shadow: 0 16px 36px rgba(0,0,0,.12);
}
.ie.show { display: flex; }
.ieToolbar { display: flex; flex-direction: row; justify-content: space-between; gap:4px; align-items:center; }
.ieToolbar .sp { flex: 1 1 auto; }
.ieBtn {
  font-size:13px; font-weight:600; line-height:1;
  padding:6px 10px; border-radius: 999px;
  border:1px solid var(--line); background:#fff; cursor:pointer;
}
.ieBtn:hover { border-color: var(--accent); }
.ieBtn.primary { background: linear-gradient(180deg,#6bc3b1,#4ea693); color:#fff; border-color:#4ea693; }
.ieText {
  width: 100%; min-height: 54px; max-height: 240px; resize: none;
  font: 14px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
  border: 1px solid var(--line); border-radius: 10px; padding: 8px;
  background: #f8fafc; color: var(--ink); outline: none;
}
.ieHint { font-size: 11px; color: #64748b; }

.colBorderCell { box-shadow: inset 3px 0 0 0 var(--accent); }
.colNoBorderCell { box-shadow: inset 3px 0 0 0 var(--bad); }
.muted{color:var(--muted)}
/* Floating tools for the selected cell */
.cellTools {
  position: fixed; z-index: 9999;
  display: none; align-items: center; gap: 8px;
  padding: 6px 8px;
  background: #fff; color: var(--ink);
  border: 1px solid var(--line);
  border-radius: 10px;
  box-shadow: 0 10px 24px rgba(0,0,0,.08);
}
.cellTools.show { display: inline-flex; }

/* optional: a tiny arrow */
.cellTools::after{
  content:''; position:absolute; width:10px; height:10px; background:#fff;
  border-left:1px solid var(--line); border-top:1px solid var(--line);
  transform: rotate(-135deg);
}

/* when above the cell */
.cellTools[data-pos="top"]::after{ bottom:-6px; left:16px; }
/* when below the cell */
.cellTools[data-pos="bottom"]::after{ top:-6px; left:16px; transform: rotate(225deg); }

/* group value buttons + add menu together */
.toolsGroup { display:inline-flex; gap:6px; align-items:center; }

/* Side editor */
.field{display:flex;flex-direction:column;gap:6px}
.field label{font-size:13px;color:#475569}
.rowX2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.pill{
  display:inline-flex;
  gap:8px;
  align-items:center;
  background:#f1f5f9;
  border:1px solid var(--line);
  border-radius:999px;
  padding:6px 10px
}
.pill input{width:60px;text-align:center}
.marklist{display:flex;flex-wrap:wrap;gap:8px}
.mark{
  display:flex;
  gap:6px;
  align-items:center;
  background:#f8fafc;
  border:1px dashed #cbd5e1;
  border-radius:10px;
  padding:6px 8px
}
.mark b{
  font-size:11px;
  background:#e2e8f0;
  padding:2px 6px;
  border-radius:6px
}
.mark input{
  background:transparent;
  border:none;
  border-bottom:1px solid #cbd5e1;
  outline:none;
  color:var(--ink)
}
.mark .del{cursor:pointer;color:#dc2626}
.small{font-size:14px;color:#475569}
p {
  margin:0 0 8px 0;
}
.footer{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:8px;
  color:var(--muted);
  font-size:13px
}
.kbd{
  font-family:ui-monospace,Menlo,Consolas,monospace;
  background:#f8fafc;
  border:1px solid #cbd5e1;
  border-bottom-width:2px;
  padding:2px 6px;
  border-radius:6px
}

/* markup visual styles */
.mk{padding:0 2px;border-radius:4px}
.mk-k{font-weight:700;background:rgba(0,0,0,0.04);color:#1e293b}
.mk-g{font-size:1.12em;background:rgba(59,130,246,0.08);color:#1e3a8a}
.mk-b{font-weight:800;font-size:1.12em;background:rgba(16,185,129,0.08);color:#064e3b}
.mk-r{background:rgba(239,68,68,0.08);color:#7f1d1d;border-bottom:1px dashed #dc2626}
.mk-n { font-style: italic; background:rgba(0,0,0,0.04); color:#1e293b; padding:0 2px; border-radius:4px }
.mk-c, .mk-s, .mk-bc, .mk-bs {
  display:inline-flex; align-items:center; justify-content:center;
  min-width:1.25em; min-height:1.25em; padding:0 .35em; line-height:1;
}
.mk-c { border:1px solid #cbd5e1; border-radius:999px; color:#111827; background:#fff }
.mk-s { border:1px solid #cbd5e1; border-radius:6px;    color:#111827; background:#fff }
.mk-bc{ background:#111827; color:#fff; border-radius:999px }
.mk-bs{ background:#111827; color:#fff; border-radius:6px }
#cheatsheet{display: flex; flex-direction: row; justify-content: space-between;}
@media (max-width: 700px){
  .row{ grid-template-columns: 1fr; column-gap: 0px; row-gap: 12px; }
  .gridwrap{ max-height: 50vh; }
  .hint{ font-size: 12px; }
  #cheatsheet{ display: flex; flex-direction: column; }
  #shortcuts{ width: 100%; }
}
@media (max-width: 410px){
  .ieToolbar { display: block; }
  .ieToolbar > div:first-child { text-align: left;}
  .ieToolbar > div:last-child { text-align: right; }
}
/* Inline editor: bottom-right floating composite menu */
.ieInputWrap { position: relative; }
.compFloat { position: absolute; right: 8px; bottom: 8px; z-index: 2; }

.compBtn {
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px; border-radius:999px; border:1px solid var(--line);
  background:#fff; color:var(--ink); font-size:13px; font-weight:600; cursor:pointer;
}
.compBtn:hover { border-color: var(--accent); }

.compBtn .menuIconSm{
  width:18px; height:18px; border-radius:6px;
  display:flex; align-items:center; justify-content:center;
  background:#f1f5f9; color:#334155; font-weight:800; font-size:12px;
}

/* open/close + list positioning (open upward) */
.compMenuList{
  position:absolute; right:0; bottom: calc(100% + 6px);
  min-width:220px; max-height:260px; overflow:auto;
  background:#fff; border:1px solid var(--line); border-radius:10px;
  box-shadow: 0 10px 24px rgba(0,0,0,.08);
  padding:6px; display:none; z-index: 3;
}
.compMenuList.open{ display:block; }

/* Active item highlight + check */
.compMenuList .menuItem.active{ background:#e2e8f0; }
.compMenuList .menuItem.active::after{
  content:'âœ“'; margin-left:auto; color:#0f766e; font-weight:800;
}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ìœ„í‚¤ ì‹œê°í‘œìš© CSV í¸ì§‘ê¸°</h1>
    </header>

    <div class="row">
      <!-- INPUT -->
      <section class="card">
        <h2>â‘  CSV ë¶ˆëŸ¬ì˜¤ê¸°</h2>
        <div class="body">
          <textarea id="csvIn" placeholder="ì—¬ê¸°ì— CSVë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”."></textarea>
          <div class="toolbar">
            <button class="primary" id="parseBtn">í‘œë¡œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <button id="loadSample">ì˜ˆì‹œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <button id="clearInput">ì´ˆê¸°í™”</button>
          </div>
        </div>
      </section>

      <!-- GRID -->
      <section class="card" style="grid-column:span 2;">
        <h2>â‘¡ í¸ì§‘í•˜ê¸°</h2>
        <div class="body" style="gap:10px">
          <div class="gridwrap">
            <table id="grid"></table>
          </div>
          <div class="small">í´ë¦­í•˜ì—¬ ì„ íƒí•˜ê³  ë”ë¸”í´ë¦­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”.</div>
        </div>
      </section>
    </div>

    <div class="row" style="margin-top:12px; margin-bottom: 30px;">
      <!-- CELL EDITOR -->

      <!-- OUTPUT -->
      <section class="card">
        <h2>â‘¢ ë‚´ë³´ë‚´ê¸°</h2>
        <div class="body">
          <textarea id="csvOut" placeholder="í‘œë¥¼ ë‚´ë³´ë‚´ë©´ ì´ê³³ì— í‘œì‹œë¼ìš”."></textarea>
          <div class="toolbar">
            <button class="primary" id="exportBtn">í‘œì—ì„œ ë‚´ë³´ë‚´ê¸°</button>
            <button id="copyOut">ë³µì‚¬</button>
          </div>
          <div class="footer">
            <span>ğŸ’¡ <span class="kbd">Ctrl/Cmd</span>+<span class="kbd">C</span>ë¡œë„ ë³µì‚¬í•  ìˆ˜ ìˆì–´ìš”.</span>
            <span id="status"></span>
          </div>
        </div>
      </section>

    <section class="card"  style="grid-column:span 2;">
      <h2>ì°¸ê³ ì‚¬í•­</h2>
      <div class="body" id="cheatsheet">
        <div class="small" style="padding: 5px;">
        <p>íˆ´ ì—†ì´ë„ ì‰¬ìš´ í¸ì§‘ì„ ìœ„í•´ ë³¸ë˜ ì‹œê°í‘œì—ì„œ <b>í–‰ê³¼ ì—´ì„ ì „í™˜í•œ</b> í˜•íƒœë¡œ í¸ì§‘ë©ë‹ˆë‹¤.<br>ì¹¸ ì„œì‹ì—ì„œ 'í–‰'ì€ <b>ì‹œê°í‘œì—ì„œì˜ í–‰</b>ìœ¼ë¡œ, í¸ì§‘ê¸°ì—ì„œëŠ” <b>ì—´</b>ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.<br>ë‹¤ë§Œ ë‹¤ë¥¸ ê³³ì—ì„œëŠ” í˜¼ë€ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‹œê°í‘œì—ì„œì˜ í–‰ê³¼ ì—´ì„ ê°ê° <b>ì—­</b>ê³¼ <b>ì—´ì°¨</b>ë¡œ í‘œì‹œí•˜ì˜€ìŠµë‹ˆë‹¤.<br>ìœ„í‚¤ì—ì„œëŠ” í–‰ê³¼ ì—´ì´ ì „í™˜ë˜ì–´ ì œëŒ€ë¡œ í‘œì‹œë©ë‹ˆë‹¤.</p>
        <p><span class="kbd">&</span>, <span class="kbd">#</span>ë¡œ ê²½ê³„ë¥¼ ì¶”ê°€Â·ì œê±°í•˜ë©´ <b>í•´ë‹¹ í–‰ ì „ì²´</b>ì— ì ìš©ë˜ë©°, <b>í–‰ ìœ„ì˜ ê²½ê³„</b>ì— ëŒ€í•´ ì ìš©ë©ë‹ˆë‹¤.</p>
        <p>í†µê³¼ ê¸°í˜¸(â‡‚)ëŠ” <span class="kbd">v</span>, íƒ€ì„ ë¡œ ê²½ìœ  ê¸°í˜¸(â€–)ëŠ” <span class="kbd">i</span>ë¡œ ì…ë ¥í•  ìˆ˜ ìˆëŠ” ë“± ì—¬ëŸ¬ ê°€ì§€ ì•½ì–´ê°€ ìˆìœ¼ë©°,<br>ë³µì¡í•œ ê¸°í˜¸ë„ ëŒ€ë¬¸ì ì¡°í•©ì„ í†µí•´ ì…ë ¥í•˜ë‚˜, í¸ì§‘ê¸°ì—ì„œ ë°”ë¡œ ë³€í™˜ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. <br>ì˜¤ë¥¸ìª½ ëª©ë¡ì„ ì°¸ê³ í•˜ì‹­ì‹œì˜¤.</p>
        <p><span class="kbd">'</span>ë¡œ ë‘˜ëŸ¬ì‹¸ì¸ ë¶€ë¶„ì€ <b>ê¸€ìê°€ ì–‘ìª½ìœ¼ë¡œ ë§ì¶”ì–´</b>ì§‘ë‹ˆë‹¤.</p>
        <p><b>ìƒˆë¡œê³ ì¹¨í•˜ë©´ ì´ˆê¸°í™”ë˜ë©° ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</b> ì¤‘ìš”í•œ ë³€ê²½ì‚¬í•­ì€ <b>ì €ì¥</b>í•˜ì„¸ìš”.</p>
      </div>
       <div id="shortcuts" class="card">
        <div class="menuGroupTitle" data-act="h">ìì£¼ ì‚¬ìš©í•˜ëŠ” ê¸°í˜¸</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â‡‚</span><span class="menuHint">í†µê³¼</span> v</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â€–</span><span class="menuHint">íƒ€ ì„ ë¡œ ê²½ìœ </span> i</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â‹¯</span><span class="menuHint">ì‹œê° ì—†ìŒ</span> x</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ã€ƒ</span><span class="menuHint">ë…¸ë…¸ì§€í…</span> q</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â€”</span><span class="menuHint">ì¢…ì°©</span> -</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â‡¨</span><span class="menuHint">í° í™”ì‚´í‘œ</span> ></div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¡</span><span class="menuHint">ê²€ì€ í™”ì‚´í‘œ</span> >></div>
       <div class="menuSep"></div>
       <div class="menuGroupTitle" data-act="h">ì¼ë°˜ ê¸°í˜¸</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">.</span><span class="menuHint">ì†Œìˆ˜ì </span> ..</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â€¥</span><span class="menuHint">ì‹œê° ì—†ìŒ ä»£</span> w</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ï¼</span><span class="menuHint">ì¢…ì°© ä»£</span> --</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ã€€</span><span class="menuHint">ì „ê° ê³µë°±</span> SPA</div>
       <div class="menuSep"></div>
       <div class="menuGroupTitle" data-act="h">2ë°° í¬ê¸° ê¸°í˜¸</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ğŸ€</span><span class="menuHint">ê·¸ë¦°ìƒ¤ ì§€ì •ì„</span> GRR</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â˜˜</span><span class="menuHint">ê·¸ë¦°ìƒ¤ ììœ ì„</span> GRN</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â˜˜</span><span class="menuHint">ì¹¨ëŒ€íŠ¹ê¸‰</span> LSL</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ğŸ€</span><span class="menuHint">ì¹¨ëŒ€ê¸‰í–‰</span> XSL</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">L</span><span class="menuHint">LíŠ¹ê¸‰</span> LEX</div>
       <div class="menuSep"></div>
       <div class="menuGroupTitle" data-act="h">í•©ì„± ê¸°í˜¸</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ğ‘°</span><span class="menuHint">ì—´ì°¨Â·ì—­ ë²ˆí˜¸</span> N{_}</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â‘ </span><span class="menuHint">ì›</span> C{_}</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ğŸ„°</span><span class="menuHint">ì‚¬ê°í˜•</span> S{_}</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¶</span><span class="menuHint">ê²€ì€ ì›</span> BC{_}</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ğŸ…°</span><span class="menuHint">ê²€ì€ ì‚¬ê°í˜•</span> BS{_}</div>
       <div class="menuSep"></div>
       <div class="menuGroupTitle" data-act="h">í™”ì‚´í‘œ</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¬</span><span class="menuHint">ìš°í•˜</span> TRD</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¬</span><span class="menuHint">ìš°ìƒ</span> TRU</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¬</span><span class="menuHint">ì¢Œí•˜</span> TLD</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â¬‘</span><span class="menuHint">ì¢Œìƒ</span> TLU</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â†²</span><span class="menuHint">í•˜ì¢Œ</span> TDL</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â†³</span><span class="menuHint">í•˜ìš°</span> TDR</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â†°</span><span class="menuHint">ìƒì¢Œ</span> TUL</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">â†±</span><span class="menuHint">ìƒìš°</span> TUR</div>
       <div class="menuSep"></div>
       <div class="menuGroupTitle" data-act="h">ë¬¸ì</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ç™¼</span><span class="menuHint">í•„ ë°œ</span> DEP</div>
       <div class="menuItem" data-act="h"><span class="menuIcon">ç€</span><span class="menuHint">ë¶™ì„ ì°©</span> ARR</div>
       </div>
      </div>
    </section>
    </div>
<script>

  // put this once (top-level)
function withGridScrollRestored(work){
  const wrap = document.querySelector('.gridwrap');
  const sL = wrap ? wrap.scrollLeft : 0;
  const sT = wrap ? wrap.scrollTop  : 0;
  const wX = window.scrollX, wY = window.scrollY;

  work(); // do the DOM changes

  // restore on next frame (after layout)
  requestAnimationFrame(()=>{
    if (wrap){
      wrap.scrollLeft = sL;
      wrap.scrollTop  = sT;
    }
    // in case page itself jumped
    window.scrollTo(wX, wY);
  });
}

  // after DOM ready
(function(){
  const gridWrap = document.querySelector('.gridwrap');
  let scheduled = false;
  function schedule(){
    if (scheduled) return;
    scheduled = true;
    requestAnimationFrame(()=>{
      scheduled = false;
      const {r,c} = state.sel || {};
      if(r==null) return hideCellTools();
      positionCellTools(r,c);
    });
  }
  window.addEventListener('scroll', schedule, {passive:true});
  window.addEventListener('resize', schedule, {passive:true});
  gridWrap && gridWrap.addEventListener('scroll', schedule, {passive:true});
})();


function mapSymbols(s){
  // apply only to plain text, never across HTML tags
  return s.replaceAll('v','â‡€')
          .replaceAll('x','â‹¯')
          .replaceAll('i','=')
          .replaceAll('q','ã€ƒ');
}

function mapSymbolsButton(s){
  // apply only to plain text, never across HTML tags
  return s.replaceAll('v','â‡‚')
          .replaceAll('x','â‹¯')
          .replaceAll('i','â€–')
          .replaceAll('q','ã€ƒ');
}
  // Clickable chip (removes on click)
function makeChip(label, kind, onClick){
  const el = document.createElement('span');
  el.className = 'chip' + (kind? ' '+kind:'');
  el.textContent = label;
  if (onClick) {
    el.style.cursor = 'pointer';
    el.title = 'Click to remove';
    el.addEventListener('click', onClick);
  }
  return el;
}

function updateCellAndRefresh(r, c, fn){
  const cell = state.rows[r][c];
  fn(cell);
   withGridScrollRestored(()=>{
    renderGrid();          // (already overridden to chunkedRender)
    syncExportNote();
  });
  selectCell(r,c);
}

/* ---------- Pretty custom dropdown inside each cell (safe attributes) ---------- */
/* ---------- Pretty custom dropdown inside each cell (no prompt) ---------- */
function buildPrettyChipMenu(r, c){
  const wrap = document.createElement('span');
  wrap.className = 'chipMenu';

  const btn = document.createElement('button');
  btn.className = 'chipAddBtn';
  btn.type = 'button';
  btn.textContent = 'ì„œì‹ ì¶”ê°€';
  wrap.appendChild(btn);

  const menu = document.createElement('div');
  menu.className = 'chipMenuList';
  menu.innerHTML = `
    <div class="menuItem" data-act="h"><span class="menuIcon">H</span> ë¨¸ë¦¬ë§ <span class="menuHint">(h)</span></div>
    <div class="menuItem" data-act="bangbang"><span class="menuIcon">!!</span> ë³‘í•©ë¨ <span class="menuHint">(!!)</span></div>

    <div class="menuSep"></div>

    <div class="menuItem" data-act="mr">
      <span class="menuIcon">â†“</span> í–‰ ë³‘í•© <span class="menuHint">(^n)</span>
    </div>
    <div class="menuItem" data-act="md">
      <span class="menuIcon">â†’</span> ì—´ ë³‘í•© <span class="menuHint">(&lt;n)</span>
    </div>
    <div class="menuItem" data-act="tilde">
      <span class="menuIcon">~</span> í–‰ ë†’ì´ <span class="menuHint">(~n px)</span>
    </div>

    <div class="menuSep"></div>
    <div class="menuItem" data-act="amp"><span class="menuIcon">&amp;</span> í–‰ ê²½ê³„ ì¶”ê°€ <span class="menuHint">(&)</span></div>
    <div class="menuItem" data-act="hash"><span class="menuIcon">#</span> í–‰ ê²½ê³„ ì œê±° <span class="menuHint">(#)</span></div>
  `;
  wrap.appendChild(menu);

  // open/close
  const closeMenu = ()=> menu.classList.remove('open');
  const toggleMenu = (e)=>{ e.stopPropagation(); menu.classList.toggle('open'); };
  btn.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(!wrap.contains(e.target)) closeMenu(); });
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeMenu(); });

  // small helper: inline number editor row
  function inlineNumberEditor(targetItem, opts){
    // remove any existing editor
    menu.querySelectorAll('.menuInlineEditor').forEach(n=> n.remove());

    const row = document.createElement('div');
    row.className = 'menuInlineEditor';
    row.style.cssText = 'display:flex;gap:6px;align-items:center;padding:8px 8px 12px 36px;';
    row.innerHTML = `
      <input type="number" min="${opts.min ?? 0}" step="${opts.step ?? 1}"
             value="${opts.value ?? 1}"
             style="width:88px;padding:6px;border:1px solid var(--line);border-radius:8px" />
      <button class="menuOk"  style="padding:6px 9px;border:1px solid var(--line);border-radius:999px;cursor:pointer">í™•ì¸</button>
    `;
    targetItem.insertAdjacentElement('afterend', row);

    const input = row.querySelector('input');
    const ok    = row.querySelector('.menuOk');
    const cancel= row.querySelector('.menuCancel');

    const apply = ()=>{
      const n = parseInt(input.value, 10);
      if (Number.isFinite(n) && n >= (opts.min ?? 0)){
        opts.onApply(n);
        closeMenu();
      } else {
        input.focus();
      }
    };
    ok.addEventListener('click', apply);
    cancel.addEventListener('click', ()=> row.remove());
    input.addEventListener('keydown', e=>{
      if(e.key==='Enter') apply();
      if(e.key==='Escape') row.remove();
    });
    setTimeout(()=> input.select(), 0);
  }

  // actions
  menu.querySelectorAll('.menuItem').forEach(item=>{
    item.addEventListener('click', (ev)=>{
      const token = item.getAttribute('data-act');

      // value setters
      if (token?.startsWith('val:')){
        const v = token.slice(4); // may be ''
        updateCellAndRefresh(r, c, (cell)=>{ cell.text=v; cell.markups=[]; });
        closeMenu();
        return;
      }

      // simple toggles
      if (token === 'h'){ updateCellAndRefresh(r,c, cell=> cell.ops.header = true); closeMenu(); return; }
      if (token === 'bangbang'){ updateCellAndRefresh(r,c, cell=> cell.ops.removed = true); closeMenu(); return; }
      if (token === 'amp'){ updateCellAndRefresh(r,c, cell=> { cell.ops.colBorder = true; cell.ops.colNoBorder = false; }); closeMenu(); return; }
      if (token === 'hash'){ updateCellAndRefresh(r,c, cell=> { cell.ops.colNoBorder = true; cell.ops.colBorder = false; }); closeMenu(); return; }

      // inline numeric editors (no prompt)
      if (token === 'mr'){
        inlineNumberEditor(item, {
          value: state.rows[r][c].ops.mergeRight || 1,
          min: 0,
          onApply: (n)=> updateCellAndRefresh(r,c, cell=> cell.ops.mergeRight = n)
        });
        return;
      }
      if (token === 'md'){
        inlineNumberEditor(item, {
          value: state.rows[r][c].ops.mergeDown || 1,
          min: 0,
          onApply: (n)=> updateCellAndRefresh(r,c, cell=> cell.ops.mergeDown = n)
        });
        return;
      }
      if (token === 'tilde'){
        inlineNumberEditor(item, {
          value: state.rows[r][c].ops.heightPx || 24,
          min: 0,
          onApply: (n)=> updateCellAndRefresh(r,c, cell=> cell.ops.heightPx = n)
        });
        return;
      }
    });
  });

  return wrap;
}

/* ---------- v/x/i quick buttons ---------- */
function buildValueButtons(r,c){
  const wrap = document.createElement('span');
  wrap.className = 'valBtns';
  ['v','x','i','q',''].forEach(v=>{
    const b=document.createElement('button');
    b.className='valBtn';
    b.type='button';
    b.innerHTML = mapSymbolsButton(v);
    b.title = `Set value to â€œ${v}â€`;
    b.addEventListener('click', ()=> updateCellAndRefresh(r,c, cell=>{ cell.text=v; cell.markups=[]; }));
    wrap.appendChild(b);
  });
  return wrap;
}

/* ---------- Render chips + controls into a cell ---------- */
function renderChipsInto(container, r, c){
  const cell = state.rows[r][c];

  // Existing chips (click to remove)
  if(cell.ops.header)       container.appendChild(makeChip('ë¨¸ë¦¬ë§','good', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.header=false)));
  if(cell.ops.removed)      container.appendChild(makeChip('ë³‘í•©ë¨','bad', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.removed=false)));
  if(cell.ops.mergeRight>0) container.appendChild(makeChip(cell.ops.mergeRight+'í–‰', '', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.mergeRight=0)));
  if(cell.ops.mergeDown>0)  container.appendChild(makeChip(cell.ops.mergeDown+'ì—´', '', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.mergeDown=0)));
  if(cell.ops.colBorder)    container.appendChild(makeChip('ê²½ê³„ì¶”ê°€','good', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.colBorder=false)));
  if(cell.ops.colNoBorder)  container.appendChild(makeChip('ê²½ê³„ì œê±°','bad',  ()=> updateCellAndRefresh(r,c, cell=> cell.ops.colNoBorder=false)));
  if(cell.ops.heightPx>0)   container.appendChild(makeChip('ë†’ì´'+cell.ops.heightPx, 'warn', ()=> updateCellAndRefresh(r,c, cell=> cell.ops.heightPx=0)));

  // NOTE: no value buttons / add menu here anymore; they live in the floating toolbar
}
</script>
<script>
// ---------------- Hardened floating tools overlay ----------------------------
// ---------------- Robust floating tools overlay (DOM-safe) -------------------
(function(){
  let cellToolsEl = null;

  // Small ready helper
  function onReady(fn){
    if (document.readyState === 'complete' || document.readyState === 'interactive') fn();
    else document.addEventListener('DOMContentLoaded', fn, { once:true });
  }

  // Fallback builders if pretty ones aren't defined yet
  function _fallbackValueButtons(r,c){
    const wrap = document.createElement('span');
    wrap.style.display='inline-flex'; wrap.style.gap='6px';
    ['v','x','i'].forEach(v=>{
      const b=document.createElement('button');
      b.type='button'; b.textContent=v;
      b.style.cssText='font-size:11px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;color:var(--ink);cursor:pointer';
      b.addEventListener('click', ()=> updateCellAndRefresh(r,c, cell=>{ cell.text=v; cell.markups=[]; }));
      wrap.appendChild(b);
    });
    return wrap;
  }
  function _fallbackAddMenu(r,c){
    const btn=document.createElement('button');
    btn.type='button'; btn.textContent='Addâ€¦';
    btn.style.cssText='font-size:11px;padding:2px 10px;border-radius:999px;border:1px solid var(--line);background:#fff;color:var(--ink);cursor:pointer';
    btn.addEventListener('click', ()=>{
      const choice = prompt('Add: h, !!, ^n, <n, &, #, ~n, or set value (v/x/i)', '');
      if(!choice) return;
      updateCellAndRefresh(r,c, (cell)=>{
        if(['v','x','i'].includes(choice)){ cell.text=choice; cell.markups=[]; return; }
        if(choice==='h'){ cell.ops.header=true; return; }
        if(choice==='!!'){ cell.ops.removed=true; return; }
        if(choice==='&'){ cell.ops.colBorder=true; cell.ops.colNoBorder=false; return; }
        if(choice==='#'){ cell.ops.colNoBorder=true; cell.ops.colBorder=false; return; }
        if(/^(\^|<)\d+$/.test(choice)){
          const n=parseInt(choice.slice(1),10);
          if(choice[0]==='^') cell.ops.mergeRight=n; else cell.ops.mergeDown=n;
          return;
        }
        if(/^~\d+$/.test(choice)){ cell.ops.heightPx=parseInt(choice.slice(1),10); return; }
        console.warn('Unknown choice:', choice);
      });
    });
    return btn;
  }

  function ensureCellTools(){
    // Body may not exist yet
    const parent = document.body || document.documentElement;
    if(!parent) return null;

    if(!cellToolsEl || !parent.contains(cellToolsEl)){
      cellToolsEl = document.createElement('div');
      cellToolsEl.className = 'cellTools';
      cellToolsEl.setAttribute('data-pos','top');
      const group = document.createElement('span');
      group.className = 'toolsGroup';
      cellToolsEl.appendChild(group);
      parent.appendChild(cellToolsEl);
    } else if(!cellToolsEl.querySelector('.toolsGroup')){
      const group = document.createElement('span');
      group.className = 'toolsGroup';
      cellToolsEl.innerHTML = '';
      cellToolsEl.appendChild(group);
    }
    return cellToolsEl;
  }

  function buildCellTools(r, c){
    const host = ensureCellTools();
    if(!host){ onReady(()=> buildCellTools(r,c)); return; }

    const group = host.querySelector('.toolsGroup');
    group.innerHTML = '';

    const makeVals = (typeof window.buildValueButtons === 'function') ? window.buildValueButtons : _fallbackValueButtons;
    const makeMenu = (typeof window.buildPrettyChipMenu === 'function') ? window.buildPrettyChipMenu : _fallbackAddMenu;

    try{
      const vals = makeVals(r,c);
      const menu = makeMenu(r,c);
      if(vals) group.appendChild(vals);
      if(menu) group.appendChild(menu);
      if(!vals && !menu) console.warn('[cellTools] No tools built.');
    }catch(err){
      console.error('[cellTools] Build failed:', err);
    }
  }

// ---- drop-in replacement ----
let _toolsRaf = 0;
function positionCellTools(r, c){
  const host = ensureCellTools();
  if(!host){ /* DOM not ready yet */ return; }

  const tbl = document.getElementById('grid');
  const cellEl = tbl && tbl.rows && tbl.rows[r] && tbl.rows[r].cells && tbl.rows[r].cells[c];
  if(!cellEl){ hideCellTools(); return; }

  // Ensure content exists
  const group = host.querySelector('.toolsGroup');
  if(group && !group.children.length) buildCellTools(r,c);

  // rAF throttle to avoid jank during scroll
  if (_toolsRaf) cancelAnimationFrame(_toolsRaf);
  _toolsRaf = requestAnimationFrame(()=>{
    const rect = cellEl.getBoundingClientRect();
    const margin = 8;

    // Measure host (show temporarily to get size)
    host.style.visibility = 'hidden';
    host.classList.add('show');
    const w = host.offsetWidth || 220;
    const h = host.offsetHeight || 36;
    host.classList.remove('show');
    host.style.visibility = '';

    const preferTop = rect.top > h + 24;
    const pos = preferTop ? 'top' : 'bottom';

    // NOTE: position: fixed uses viewport coordinates â€” DO NOT add window.scrollX/Y
    let top = preferTop ? rect.top - h - margin : rect.bottom + margin;
    let left = Math.min(Math.max(6, rect.left), window.innerWidth - w - 6);

    host.style.top = `${top}px`;
    host.style.left = `${left}px`;
    host.dataset.pos = pos;
    host.classList.add('show');
  });
}


  function hideCellTools(){
    const host = ensureCellTools();
    if(host) host.classList.remove('show');
  }

  // Expose globally
  window.buildCellTools = buildCellTools;
  window.positionCellTools = positionCellTools;
  window.hideCellTools = hideCellTools;

  // Reposition on scroll/resize after DOM ready
  onReady(()=>{
    const handler = ()=>{
      const {r,c} = state.sel || {};
      if(r==null) return hideCellTools();
      positionCellTools(r,c);
    };
    window.addEventListener('scroll', handler, {passive:true});
    window.addEventListener('resize', handler, {passive:true});
    document.querySelector('.gridwrap')?.addEventListener('scroll', handler, {passive:true});
  });
})();

</script>
<script>
// --- Data model --------------------------------------------------------------
// Each cell stores: { text, ops: {header, removed, mergeRight, mergeDown, colBorder}, markups: [{t:'k|g|b|r', v:string}] }

const state = { rows: [], sel: {r:null,c:null} };

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
  const rows = lines.map(line=> line.split(/,(?=(?:[^']*'[^']*')*[^']*$)/).map(s=> s.trim()));
  return rows.map(r=> r.map(parseCell));
}

function parseCell(raw){
  const cell = { 
  raw, text:"", 
  ops:{
    header:false, removed:false, 
    mergeRight:0, mergeDown:0, 
    colBorder:false,     // &  (teal)
    colNoBorder:false,   // #  (red)
    heightPx:0           // ~n
  }, 
  markups:[] 
};
  if(!raw) return cell;

    // ...
  let pre = "", post="";
  const idx = raw.indexOf(";");
  if(idx>=0){ pre = raw.slice(0, idx).trim(); post = raw.slice(idx+1).trim(); }
  else { post = raw.trim(); }

  // NEW: allow ops-only cells without a semicolon (e.g., "!!", "^2", "<3", "~120", "#", "&", "h")
  if (!pre && post && /^(\s*(?:!!|h|&|#|~\s*\d+|\^\s*\d+|<\s*\d+))+\s*$/.test(post)) {
    pre = post; 
    post = '';
  }


  // parse ops in `pre`
  if(pre){
    if(pre.includes('h')) cell.ops.header = true;
    if(pre.includes('!!')) cell.ops.removed = true;
    const mR = pre.match(/\^(\d+)/); if(mR) cell.ops.mergeRight = parseInt(mR[1],10);
    const mD = pre.match(/<\s*(\d+)/); if(mD) cell.ops.mergeDown = parseInt(mD[1],10);
    const mH = pre.match(/~\s*(\d+)/); if(mH) cell.ops.heightPx = parseInt(mH[1], 10);
    if(pre.includes('&')) cell.ops.colBorder = true;
    // add after existing &/^/</!!/h parsing
if (pre.includes('#')) cell.ops.colNoBorder = true;
  }

  // parse markups sequence like kTEXT. gTEXT. bTEXT. rTEXT.
  let rest = post;
  const marks=[];
  while(/^([kgrb])/.test(rest)){
    const t = rest[0];
    const afterT = rest.slice(1);
    const dot = afterT.indexOf('.')
    if(dot>=0){
      const v = afterT.slice(0, dot);
      marks.push({t,v});
      rest = afterT.slice(dot+1).trim();
    } else { break; }
  }
  cell.markups = marks;
  cell.text = rest; // remaining plain text (may be empty)
  cell.raw = post;
  return cell;
}

function cellToString(cell){
  const ops = [];
  if(cell.ops.header) ops.push('h');
  if(cell.ops.removed) ops.push('!!');
  if(cell.ops.mergeRight>0) ops.push('^'+cell.ops.mergeRight);
  if(cell.ops.mergeDown>0) ops.push('<'+cell.ops.mergeDown);
  if(cell.ops.colBorder) ops.push('&');
  if (cell.ops.colNoBorder) ops.push('#');   // new
  if (cell.ops.heightPx>0)  ops.push('~' + cell.ops.heightPx); // new

  const left = ops.join('');

  const rightParts = [];
  for(const m of cell.markups){ rightParts.push(m.t + (m.v??'' ) + '.') }
  if(cell.text) rightParts.push(cell.text);

  if(left && rightParts.length) return left + '; ' + rightParts.join(' ');
  if(left) return left + ';';
  return rightParts.join(' ');
}

(function(){
  const tbl = document.getElementById('grid');
  let touchTimer = null;

  // single tap selects, long-press opens editor
  tbl.addEventListener('touchstart', (e)=>{
    const td = e.target.closest('td,th'); if(!td) return;
    const r = td.parentNode.rowIndex, c = td.cellIndex;
    selectCell(r,c);
    clearTimeout(touchTimer);
    touchTimer = setTimeout(()=> {
      if (window.__openOverlayEditor) window.__openOverlayEditor(r,c);
    }, 500); // ~0.35s press
  }, {passive:true});

  tbl.addEventListener('touchend', ()=> clearTimeout(touchTimer), {passive:true});
  tbl.addEventListener('touchmove', ()=> clearTimeout(touchTimer), {passive:true});

  // desktop still uses dblclick (you already wired it)
})();

(function(){
  function reposition(){
    const sel = state.sel || {};
    if (sel.r==null) return;
    // Re-run your positioning so it uses the *current* rect
    if (window.positionCellTools) positionCellTools(sel.r, sel.c);
  }

  if (window.visualViewport){
    visualViewport.addEventListener('resize', reposition, {passive:true});
    visualViewport.addEventListener('scroll',  reposition, {passive:true});
  }
  window.addEventListener('orientationchange', ()=> setTimeout(reposition, 50), {passive:true});
})();

// --- Grid rendering ----------------------------------------------------------
function renderGrid(){
  const host = document.getElementById('cellEditor');
  // If the side editor panel isn't in this layout, just no-op safely
  if(!host){ return; }

  host.innerHTML='';
  const {r,c} = state.sel || {};
  if(r==null){ host.innerHTML='<div class="muted">Select a cell in the grid.</div>'; return; }
  const cell = state.rows[r][c];
  const tbl = document.getElementById('grid');
  tbl.innerHTML = '';
  state.rows.forEach((row,ri)=>{
    const tr = document.createElement('tr');
    row.forEach((cell,ci)=>{
      const td = document.createElement(ri<2? 'th':'td');
td.className = 'cell' + (cell.ops.header? ' headerCell':'');
if (cell.ops.colBorder)   td.classList.add('colBorderCell');
if (cell.ops.colNoBorder) td.classList.add('colNoBorderCell'); // NEW
if (cell.ops.removed) {
  td.classList.add('removedCell');
}

      const div = document.createElement('div');
div.innerHTML = renderMarkupHTML(cell) || '&nbsp;';
td.appendChild(div);

      const chips = document.createElement('div');
chips.className='chips';
renderChipsInto(chips, ri, ci);
td.appendChild(chips);

      td.addEventListener('click',()=> selectCell(ri,ci));
      td.addEventListener('dblclick',()=> window.__openOverlayEditor(ri, ci));td.addEventListener('dblclick',()=> startInlineEdit(td, ri, ci));
      if(state.sel.r===ri && state.sel.c===ci){ td.style.outline='2px solid var(--accent)'; td.style.outlineOffset='-2px'; }
      tr.appendChild(td);
    });
    tbl.appendChild(tr);
  });
}

function displayText(cell){
  let t = cell.text || cell.markups.map(m=>m.v).filter(Boolean).join(' ');
  if(!t && cell.markups.some(m=>m.v)) t = cell.markups.map(m=>m.v).join(' ');
  return t || cellToString(cell) || '';
}

function clip(s){ return s.length>8? s.slice(0,8)+'â€¦': s }

function startInlineEdit(td, r, c){
  const cell = state.rows[r][c];

  // Show the whole editable post-semicolon string: existing markups as "kA. gB. rC." + tail text
  const prefix = (cell.markups||[]).map(m => (m.t || '') + (m.v || '') + '.').join(' ');
  const seed = prefix + (prefix && cell.text ? ' ' : '') + (cell.text || '');

  const ta = document.createElement('textarea');
  ta.value = seed;
  ta.rows = 1;
  const auto = ()=>{ ta.style.height='auto'; ta.style.height = (ta.scrollHeight)+"px"; };
  td.innerHTML='';
  td.appendChild(ta);
  ta.focus(); auto();
  ta.addEventListener('input', auto);
  ta.addEventListener('keydown', e=>{
    if(e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      const {selectionStart:s, selectionEnd:ePos, value:v} = ta;
      ta.value = v.slice(0,s) + '/' + v.slice(ePos);
      ta.selectionStart = ta.selectionEnd = s+1; auto();
    }
    if(e.key==='Escape'){  withGridScrollRestored(()=>{
    renderGrid();          // (already overridden to chunkedRender)
  }); selectCell(r,c); }
  });
  ta.addEventListener('blur', ()=>{
    // Re-parse the user's text as post-semicolon content (keep ops as-is)
    const parsed = parseCell('; ' + ta.value); // reuse parser
    cell.markups = parsed.markups || [];
    cell.text = parsed.text || '';
    withGridScrollRestored(()=>{
    renderGrid();          // (already overridden to chunkedRender)
  });
     selectCell(r,c);
  });
}

function selectCell(r,c){
  state.sel={r,c};
  withGridScrollRestored(()=>{
  renderGrid();
  });
  // NEW:
  buildCellTools(r,c);
  positionCellTools(r,c);
}


// --- Cell editor -------------------------------------------------------------
// --- Step 3: Selected Cell editor (intuitive inline markup editing) ----------
function renderEditor(){
  const host = document.getElementById('cellEditor');
  host.innerHTML='';
  const {r,c} = state.sel || {};
  if(r==null){ host.innerHTML='<div class="muted">Select a cell in the grid.</div>'; return; }
  const cell = state.rows[r][c];

  // Build a single "post content" string (all after the semicolon)
  const postString = buildPostString(cell); // e.g., "kêµµê²Œ. ITX/rë§ˆìŒ. ë"

  // --- Post content field (full, editable, markups anywhere) ---
  const postField = el(`
    <div class="field">
      <label>Post content (markups anywhere: kTEXT. gTEXT. bTEXT. rTEXT.) â€” â€œ/â€ renders as line break</label>
      <textarea id="edPost" rows="3" style="background:#f8fafc;border:1px solid var(--line);border-radius:10px;padding:8px;color:var(--ink);resize:vertical"></textarea>
    </div>
  `);
  postField.querySelector('#edPost').value = postString;
  host.appendChild(postField);

  // --- Quick insert bar ---
  const bar = el(`
    <div class="toolbar" style="margin-top:4px">
      <button data-t="k" title="Insert kTEXT.">+ Bold (k)</button>
      <button data-t="g" title="Insert gTEXT.">+ Larger (g)</button>
      <button data-t="b" title="Insert bTEXT.">+ Bold+Larger (b)</button>
      <button data-t="r" title="Insert rTEXT.">+ Rotate (r)</button>
      <span class="small" style="margin-left:auto">Tip: select text first to wrap; otherwise youâ€™ll be prompted.</span>
    </div>
  `);
  host.appendChild(bar);

  const ta = postField.querySelector('#edPost');
  bar.querySelectorAll('button[data-t]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const t = btn.getAttribute('data-t');
      insertMarkupSnippet(ta, t);
      previewNow(); // update live preview
    });
  });

  // --- Live preview (HTML) ---
  const prevWrap = el(`
    <div class="field">
      <label>Preview</label>
      <div id="edPreview" style="min-height:36px;background:#f8fafc;border:1px dashed var(--line);border-radius:10px;padding:8px"></div>
    </div>
  `);
  host.appendChild(prevWrap);
  const prevEl = prevWrap.querySelector('#edPreview');

  function previewNow(){
    // parse with your parser by prepending a semicolon
    const parsed = parseCell('; ' + ta.value);
    // render with your inline renderer
    const html = renderMarkupHTML(parsed) || '&nbsp;';
    prevEl.innerHTML = html;
  }
  ta.addEventListener('input', previewNow);
  previewNow();

  // --- Ops (header/removed/merges/colBorder) ---
  host.appendChild(el(`
    <div class="rowX2" style="margin-top:6px">
      <label class="pill">Header <input type="checkbox" id="edHeader" ${cell.ops.header?'checked':''}></label>
      <label class="pill">Removed (!!) <input type="checkbox" id="edRemoved" ${cell.ops.removed?'checked':''}></label>
    </div>
  `));
  host.appendChild(el(`
    <div class="rowX2" style="margin-top:6px">
      <div class="pill">^ Right merge <input id="edMR" type="number" min="0" value="${cell.ops.mergeRight}"></div>
      <div class="pill">&lt; Down merge <input id="edMD" type="number" min="0" value="${cell.ops.mergeDown}"></div>
    </div>
  `));
  host.appendChild(el(`
    <div class="field" style="margin-top:6px">
      <label>Column Border (&amp;)</label>
      <label class="pill"><input type="checkbox" id="edColBorder" ${cell.ops.colBorder? 'checked':''}/> &nbsp; Show border on this column</label>
    </div>
  `));
  // Add below the Header/Removed row:
host.appendChild(el(`
  <div class="rowX2" style="margin-top:6px">
    <label class="pill">Column Border (&) <input type="checkbox" id="edColBorder" ${cell.ops.colBorder?'checked':''}></label>
    <label class="pill">No Column Border (#) <input type="checkbox" id="edColNoBorder" ${cell.ops.colNoBorder?'checked':''}></label>
  </div>
`));

// Height input
host.appendChild(el(`
  <div class="field" style="margin-top:6px">
    <label>Cell height (~n px)</label>
    <div class="pill">~ <input id="edHeight" type="number" min="0" value="${cell.ops.heightPx||0}" style="width:80px"> px</div>
  </div>
`));


  // --- Apply ---
  const saveBar = el(`<div class="toolbar" style="margin-top:8px"><button class="primary" id="apply">Apply Changes</button></div>`);
  host.appendChild(saveBar);
  saveBar.querySelector('#apply').addEventListener('click', ()=>{
    // Re-parse entire post content so leading markups become cell.markups, rest stays in text
    const parsed = parseCell('; ' + ta.value);
    cell.markups   = parsed.markups || [];
    cell.text      = parsed.text    || '';
    // Ops
    cell.ops.header     = document.getElementById('edHeader').checked;
    cell.ops.removed    = document.getElementById('edRemoved').checked;
    cell.ops.mergeRight = parseInt(document.getElementById('edMR').value||'0',10);
    cell.ops.mergeDown  = parseInt(document.getElementById('edMD').value||'0',10);
cell.ops.colBorder   = document.getElementById('edColBorder').checked;
cell.ops.colNoBorder = document.getElementById('edColNoBorder').checked;
cell.ops.heightPx    = parseInt(document.getElementById('edHeight').value||'0', 10) || 0;

    // Refresh
    renderGrid(); syncExportNote();
    // Keep selection
    selectCell(r,c);
  });
}

// Build a single editable string for the "post content" area from a cell
function buildPostString(cell){
  const prefix = (cell.markups||[]).map(m => (m.t||'') + (m.v||'') + '.').join(' ');
  return prefix + (prefix && cell.text ? ' ' : '') + (cell.text || '');
}

// Insert k/g/b/r snippet at caret (or wrap selection)
function insertMarkupSnippet(textarea, t){
  textarea.focus();
  const selStart = textarea.selectionStart ?? 0;
  const selEnd   = textarea.selectionEnd   ?? selStart;
  const value = textarea.value;

  let insertText = '';
  if(selStart !== selEnd){
    // wrap selection -> kSELECTED.
    const selected = value.slice(selStart, selEnd);
    insertText = `${t}${selected}.`;
  }else{
    // prompt for text
    const v = prompt(`${t.toUpperCase()} text:`, '');
    if(v===null) return; // canceled
    insertText = `${t}${v}.`;
  }

  const newVal = value.slice(0, selStart) + insertText + value.slice(selEnd);
  textarea.value = newVal;

  // place caret after inserted snippet
  const newPos = selStart + insertText.length;
  textarea.selectionStart = textarea.selectionEnd = newPos;
}

function esc(s){ return (s??'').replace(/[&<>"']/g, m=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]) ); }
function el(html){ const t=document.createElement('template'); t.innerHTML=html.trim(); return t.content.firstChild }

// --- Controls ----------------------------------------------------------------

document.getElementById('parseBtn').addEventListener('click', ()=>{
  const input = document.getElementById('csvIn').value;
  state.rows = parseCSV(input);
  state.sel={r:0,c:0};
  renderGrid();;
  syncExportNote();
});

document.getElementById('clearInput').addEventListener('click', ()=>{
  document.getElementById('csvIn').value='';
});

document.getElementById('exportBtn').addEventListener('click', ()=>{
  const out = exportCSV();
  const ta = document.getElementById('csvOut');
  ta.value = out; ta.focus(); ta.select();
  setStatus('ë‚´ë³´ë‚´ê¸° ì™„ë£Œ.');
});

document.getElementById('copyOut').addEventListener('click', ()=>{
  const ta = document.getElementById('csvOut');
  ta.focus(); ta.select(); document.execCommand('copy');
  setStatus('ë³µì‚¬ ì™„ë£Œ.');
});

function exportCSV(){
  const lines = state.rows.map(row=> row.map(cellToString).join(', '));
  return lines.join('\n');
}

function setStatus(msg){ const el=document.getElementById('status'); if(!el) return; el.textContent=msg; setTimeout(()=> el.textContent='', 2000); }

function syncExportNote(){ const o=document.getElementById('csvOut'); if(o) o.value = exportCSV(); }

// Sample data
const SAMPLE = ` h<100~50; bSPAí–‰ë³µ > ë§ë‘ > í­ì‹ SPA., ^3; rê±°ë¦¬., !!;, !!;, 0..0, ^2; 5..0, !!;, 10..0, SPA, h<4; 'ë¹„ê³ '
!!;, h; 'ì—´ì°¨ë²ˆí˜¸', h; 'ì—´ì°¨ëª…', h; 'ì‹œë°œ', SPA, ^2; å¼, !!;, SPA, h; 'í–‰ì„ ', !!;
!!;, !!;, !!;, !!;, 'í–‰ë³µ', ^2; b'ë§ë‘'., !!;, 'í­ì‹ ', !!;, !!;
!!;, !!;, !!;, !!;, DEP, ARR, &; DEP, ARR, !!;, !!;
!!;, N{9999}, XSL/S{kæ€¥è¡Œ.}/rë§ë‘., ê·€ì—¼/2250, 400, 420, --, x, ë§ë‘/420, ê°€ë‚˜/ì•„ì•¼
!!;, N{1}, C{å¿«é€Ÿ}, í–‰ë³µ/510, 510, 540, 545, 615, í­ì‹ /615, ë‹¤ë¼/ì–´ì—¬ `;

document.getElementById('loadSample').addEventListener('click', ()=>{
  document.getElementById('csvIn').value = SAMPLE;
});

// Keyboard nav (basic)
document.addEventListener('keydown', (e)=>{
  if(!document.activeElement || document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='TEXTAREA') return;
  const {r,c} = state.sel; if(r==null) return;
  if(e.key==='ArrowRight') selectCell(r, Math.min(c+1, state.rows[r].length-1));
  if(e.key==='ArrowLeft')  selectCell(r, Math.max(c-1, 0));
  if(e.key==='ArrowDown')  selectCell(Math.min(r+1, state.rows.length-1), c);
  if(e.key==='ArrowUp')    selectCell(Math.max(r-1, 0), c);
});
</script>
<script>
// Safely escape HTML
function escapeHTML(s){
  return (s??'').replace(/[&<>"']/g, m => (
    {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]
  ));
}

// Turn a cell into inline-rendered HTML with styled markups.
// Also converts '/' to <br/> for display only.
// Safely escape HTML
function escapeHTML(s){
  return (s??'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"\'":'&#39;'}[m]));
}

function renderInlineMarkupsInText(text){
  if(text==null) return '';
  const reComp = /(BC|BS|C|S|N)\{([^}]*)\}/g;
  const out = [];
  let last = 0, m;

  while((m = reComp.exec(text))){
    const before = text.slice(last, m.index);
    if (before) out.push(_renderDotMarkups(before));

    const kind = m[1];
    const inner = m[2];
    // ì¤‘ì²© í—ˆìš©: ê´„í˜¸ ì•ˆìª½ë„ ë‹¤ì‹œ ë Œë” (k/g/b/r, ë˜ ë‹¤ë¥¸ í•©ì„±ê¸°í˜¸ í¬í•¨)
    const innerHTML = renderInlineMarkupsInText(inner);
    out.push(_wrapComposite(kind, innerHTML));

    last = reComp.lastIndex;
  }
  if(last < text.length){
    out.push(_renderDotMarkups(text.slice(last)));
  }
  return out.join('');
}

// k/g/b/r (ë§ˆì¹¨í‘œ ëë‚˜ëŠ” í‘œê¸°) ì²˜ë¦¬
function _renderDotMarkups(src){
  const parts = [];
  const re = /([kgrb])([^.]*)\./g;
  let i = 0, m;

  while((m = re.exec(src))){
    if(m.index > i){
      const chunk = src.slice(i, m.index);
      parts.push(mapSymbols(escapeHTML(chunk).replaceAll('/', '<br/>')));
    }
    const t = m[1], v = m[2] || '';
    const cls = t==='k' ? 'mk mk-k' : t==='g' ? 'mk mk-g' : t==='b' ? 'mk mk-b' : 'mk mk-r';
    const val = mapSymbols(escapeHTML(v).replaceAll('/', '<br/>'));
    if(t==='r'){
      parts.push(`<span class="${cls}">${val}<span class="rot">â†»</span></span>`);
    } else {
      parts.push(`<span class="${cls}">${val}</span>`);
    }
    i = re.lastIndex;
  }
  if(i < src.length){
    const tail = src.slice(i);
    parts.push(mapSymbols(escapeHTML(tail).replaceAll('/', '<br/>')));
  }
  return parts.join('');
}

// í•©ì„±ê¸°í˜¸ ë˜í¼
function _wrapComposite(kind, innerHTML){
  switch(kind){
    case 'N':  return `<span class="mk mk-n">${innerHTML}</span>`;
    case 'C':  return `<span class="mk mk-c">${innerHTML}</span>`;
    case 'S':  return `<span class="mk mk-s">${innerHTML}</span>`;
    case 'BC': return `<span class="mk mk-bc">${innerHTML}</span>`;
    case 'BS': return `<span class="mk mk-bs">${innerHTML}</span>`;
    default:   return innerHTML;
  }
}

// Render k/g/b/r that were parsed at the front *and*
// any inline markups found in the remaining text.
function renderMarkupHTML(cell){
  const blocks = [];
  // leading markups
  for(const m of (cell.markups||[])){
    const cls = m.t==='k' ? 'mk mk-k'
              : m.t==='g' ? 'mk mk-g'
              : m.t==='b' ? 'mk mk-b'
              :            'mk mk-r';
    const val = mapSymbols(escapeHTML(m.v||'').replaceAll('/', '<br/>'));
    if(m.t==='r'){
      blocks.push(`<span class="${cls}">${val}<span class="rot">â†»</span></span>`);
    }else{
      blocks.push(`<span class="${cls}">${val}</span>`);
    }
  }
  // the remaining text (may include inline markups)
  const tailHTML = renderInlineMarkupsInText(cell.text||'');
  if(blocks.length && tailHTML) return blocks.join(' ') + ' ' + tailHTML;
  return blocks.join(' ') || tailHTML || '';
}

</script>
<script>
  // ---------- Floating inline editor (doesn't change table size) ---------------
let _ieEl = null, _ieTA = null, _ieCell = null;

function ensureInlineEditor(){
  if (_ieEl && document.body.contains(_ieEl)) return _ieEl;
  const host = document.createElement('div');
  host.className = 'ie';
  host.innerHTML = `
    <div class="ieToolbar">
      <div>
      <button class="ieBtn" data-act="slash">ì¤„ë°”ê¿ˆ</button>
      <button class="ieBtn" data-act="k">êµµê²Œ</button>
      <button class="ieBtn" data-act="g">í¬ê²Œ</button>
      <button class="ieBtn" data-act="b">ê°•ì¡°</button>
      <button class="ieBtn" data-act="r">ì„¸ë¡œì“°ê¸°</button>
      </div>
      <div>
      <span class="sp"></span>
      <button class="ieBtn" data-act="cancel">ì·¨ì†Œ</button>
      <button class="ieBtn primary" data-act="save">ì €ì¥</button>
      </div>
    </div>
    <textarea class="ieText" rows="2" placeholder=""></textarea>
    <div class="ieHint"><span class="kbd">Enter</span>ë¡œ ì¤„ë°”ê¿ˆ Â· <span class="kbd">Esc</span>ë¡œ ì·¨ì†Œ Â· <span class="kbd">Ctrl/Cmd</span>+<span class="kbd">Enter</span>ë¡œ ì…ë ¥</div>
  `;
  
  document.body.appendChild(host);
  
  // --- í•©ì„±ê¸°í˜¸ ë“œë¡­ë‹¤ìš´ UI ì¶”ê°€ ---
const leftBar = host.querySelector('.ieToolbar > div:first-child');
const comp = document.createElement('span');
comp.className = 'chipMenu';
comp.innerHTML = `
  <button class="ieBtn chipAddBtn" type="button">í•©ì„±ê¸°í˜¸ â–¾</button>
  <div class="chipMenuList ieCompMenu">
    <div class="menuGroupTitle">ì¢…ë¥˜ ì„ íƒ</div>
    <div class="menuItem" data-kind="N"><span class="menuIcon">ğ‘°</span> ì—´ì°¨Â·ì—­ ë²ˆí˜¸ <span class="menuHint">N{}</span></div>
    <div class="menuItem" data-kind="C"><span class="menuIcon">â‘ </span> í° ì› <span class="menuHint">C{}</span></div>
    <div class="menuItem" data-kind="S"><span class="menuIcon">ğŸ„°</span> í° ì‚¬ê°í˜• <span class="menuHint">S{}</span></div>
    <div class="menuItem" data-kind="BC"><span class="menuIcon">â¶</span> ê²€ì€ ì› <span class="menuHint">BC{}</span></div>
    <div class="menuItem" data-kind="BS"><span class="menuIcon">ğŸ…°</span> ê²€ì€ ì‚¬ê°í˜• <span class="menuHint">BS{}</span></div>
    <div class="menuSep"></div>
    <div class="menuItem">
      <input type="text" class="compText" placeholder="ë‚´ìš© ì…ë ¥" style="width: 88px; flex:1;padding:6px;border:1px solid var(--line);border-radius:8px" />
      <button class="menuOk" style="padding:6px 9px;border:1px solid var(--line);border-radius:999px;cursor:pointer">+</button>
    </div>
  </div>`;
leftBar.appendChild(comp);

let currentKind = 'C';
const menu  = comp.querySelector('.ieCompMenu');
const btn   = comp.querySelector('.chipAddBtn');
const input = comp.querySelector('.compText');

function closeComp(){ menu.classList.remove('open'); }
btn.addEventListener('click', (e)=>{ e.stopPropagation(); menu.classList.toggle('open'); if(menu.classList.contains('open')) input?.focus(); });
document.addEventListener('click', (e)=>{ if(!comp.contains(e.target)) closeComp(); });

// ì¢…ë¥˜ ì„ íƒ: ì„ íƒ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ë˜í•‘, ì—†ìœ¼ë©´ ì…ë ¥ì¹¸ í¬ì»¤ìŠ¤
menu.querySelectorAll('.menuItem[data-kind]').forEach(it=>{
  it.addEventListener('click', ()=>{
    currentKind = it.getAttribute('data-kind') || 'C';
    const s = _ieTA.selectionStart ?? 0;
    const e = _ieTA.selectionEnd ?? s;
    if (s !== e){
      const sel = _ieTA.value.slice(s, e);
      _ieInsertComposite(currentKind, sel);
      closeComp();
    } else {
      input?.focus();
    }
  });
});

menu.querySelector('.menuOk')?.addEventListener('click', ()=>{
  const txt = input?.value || '';
  if(!txt){ input?.focus(); return; }
  _ieInsertComposite(currentKind, txt);
  input.value = '';
  closeComp();
});

// ì‚½ì… ë¡œì§
function _ieInsertComposite(kind, content){
  const ta = _ieTA; if(!ta) return;
  const s = ta.selectionStart ?? 0;
  const e = ta.selectionEnd ?? s;
  const insertText = `${kind}{${content}}`;
  ta.value = ta.value.slice(0,s) + insertText + ta.value.slice(e);
  const pos = s + insertText.length;
  ta.selectionStart = ta.selectionEnd = pos;
  _ieAutosize();
}

  _ieEl = host;
  _ieTA = host.querySelector('.ieText');

    _ieEl = host;
  _ieTA = host.querySelector('.ieText');

/* ===== í•©ì„±ê¸°í˜¸: ì…ë ¥ì°½ ì˜¤ë¥¸ìª½ ì•„ë˜ í”Œë¡œíŒ… ë²„íŠ¼ ===== */
(function attachCompositeAtTextareaBottomRight(){
  const ta = _ieTA;
  if(!ta) return;

  // í•œ ë²ˆë§Œ ê°ì‹¸ë„ë¡
  if(!ta.parentElement.classList.contains('ieInputWrap')){
    const wrap = document.createElement('div');
    wrap.className = 'ieInputWrap';
    ta.parentElement.insertBefore(wrap, ta);
    wrap.appendChild(ta);
  }
  const wrap = ta.parentElement;

  // ê¸°ì¡´ ìœ„ìª½ íˆ´ë°”ì— ë§Œë“  í•©ì„±ê¸°í˜¸ ë©”ë‰´ê°€ ìˆë‹¤ë©´ ìˆ¨ê¹€(ì„ íƒ)
  _ieEl.querySelector('.chipMenu')?.remove();

  // í”Œë¡œíŒ… ì»¨íŠ¸ë¡¤ ë§Œë“¤ê¸°
  let currentKind = 'C'; // ê¸°ë³¸ C
  const iconFor = (k)=> ({N:'ğ‘°', C:'â‘ ', S:'ğŸ„°', BC:'â¶', BS:'ğŸ…°'})[k] || 'â—¦';
  const labelFor= (k)=> k;

  const float = document.createElement('div');
  float.className = 'compFloat';
  float.innerHTML = `
    <button type="button" class="compBtn">
      <span class="menuIconSm">${iconFor(currentKind)}</span>
      <span class="menuText">${labelFor(currentKind)}</span>
    </button>
    <div class="compMenuList">
      <div class="menuGroupTitle">ì¢…ë¥˜ ì„ íƒ</div>
      <div class="menuItem" data-kind="N"><span class="menuIcon">ğ‘°</span> ì—´ì°¨Â·ì—­ ë²ˆí˜¸ <span class="menuHint">N{}</span></div>
      <div class="menuItem" data-kind="C"><span class="menuIcon">â‘ </span> í° ì› <span class="menuHint">C{}</span></div>
      <div class="menuItem" data-kind="S"><span class="menuIcon">ğŸ„°</span> í° ì‚¬ê°í˜• <span class="menuHint">S{}</span></div>
      <div class="menuItem" data-kind="BC"><span class="menuIcon">â¶</span> ê²€ì€ ì› <span class="menuHint">BC{}</span></div>
      <div class="menuItem" data-kind="BS"><span class="menuIcon">ğŸ…°</span> ê²€ì€ ì‚¬ê°í˜• <span class="menuHint">BS{}</span></div>
      <div class="menuSep"></div>
      <div class="menuItem">
        <input type="text" class="compText" placeholder="ë‚´ìš© ì…ë ¥"
               style="width: 88px; flex:1;padding:6px;border:1px solid var(--line);border-radius:8px" />
        <button class="menuOk" style="padding:6px 9px;border:1px solid var(--line);border-radius:999px;cursor:pointer">ì‚½ì…</button>
      </div>
    </div>
  `;
  // ì¤‘ë³µ ìƒì„± ë°©ì§€
  wrap.querySelector('.compFloat')?.remove();
  wrap.appendChild(float);

  const btn   = float.querySelector('.compBtn');
  const menu  = float.querySelector('.compMenuList');
  const input = float.querySelector('.compText');

  const updateBtn = ()=>{
    float.querySelector('.menuIconSm').textContent = iconFor(currentKind);
    float.querySelector('.menuText').textContent    = labelFor(currentKind);
    menu.querySelectorAll('.menuItem[data-kind]').forEach(it=>{
      it.classList.toggle('active', it.getAttribute('data-kind')===currentKind);
    });
  };
  updateBtn();

  const toggleMenu = (e)=>{ e.stopPropagation(); menu.classList.toggle('open'); if(menu.classList.contains('open')) input?.focus(); };
  const closeMenu  = ()=> menu.classList.remove('open');
  btn.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(!float.contains(e.target)) closeMenu(); });

  // ì„ íƒ ì¦‰ì‹œ ë˜í•‘(ë“œë˜ê·¸ ì„ íƒì´ ìˆëŠ” ê²½ìš°)
  menu.querySelectorAll('.menuItem[data-kind]').forEach(it=>{
    it.addEventListener('click', ()=>{
      currentKind = it.getAttribute('data-kind') || 'C';
      updateBtn();
      const s = _ieTA.selectionStart ?? 0;
      const e = _ieTA.selectionEnd ?? s;
      if (s !== e){
        const sel = _ieTA.value.slice(s,e);
        _ieInsertComposite(currentKind, sel);
        closeMenu();
      } else {
        input?.focus();
      }
    });
  });

  // ì…ë ¥ì¹¸ â†’ ì‚½ì…
  menu.querySelector('.menuOk')?.addEventListener('click', ()=>{
    const txt = (input?.value || '').trim();
    if(!txt){ input?.focus(); return; }
    _ieInsertComposite(currentKind, txt);
    input.value = '';
    closeMenu();
  });

  // í•©ì„±ê¸°í˜¸ ì‹¤ì œ ì‚½ì…
  function _ieInsertComposite(kind, content){
    const ta = _ieTA; if(!ta) return;
    const s = ta.selectionStart ?? 0;
    const e = ta.selectionEnd ?? s;
    const insertText = `${kind}{${content}}`;
    ta.value = ta.value.slice(0,s) + insertText + ta.value.slice(e);
    const pos = s + insertText.length;
    ta.selectionStart = ta.selectionEnd = pos;
    _ieAutosize();
    ta.focus();
  }
})();


  // toolbar actions
  host.querySelectorAll('.ieBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const act = btn.getAttribute('data-act');
      if (act==='save') _ieSave();
      else if (act==='cancel') _ieClose(false);
      else if (act==='slash') _ieInsert('/');
      else if (['k','g','b','r'].includes(act)) _ieInsertMarkup(act);
    });
  });

  // key handling
  _ieTA.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey){
      e.preventDefault();
      _ieInsert('/');
    } else if ((e.key==='Enter' && (e.ctrlKey || e.metaKey))){
      e.preventDefault(); _ieSave();
    } else if (e.key==='Escape'){
      e.preventDefault(); _ieClose(false);
    }
  });

  // stop clicks from bubbling (donâ€™t change selection)
  host.addEventListener('mousedown', e=> e.stopPropagation());
  host.addEventListener('click', e=> e.stopPropagation());

  // click outside closes (save)
  document.addEventListener('mousedown', (e)=>{
    if(!_ieEl || _ieEl.style.display!=='flex') return;
    if(!_ieEl.contains(e.target)) _ieSave();
  });

  return _ieEl;
}

function _ieAutosize(){
  if(!_ieTA) return;
  _ieTA.style.height = 'auto';
  _ieTA.style.height = Math.min(240, _ieTA.scrollHeight) + 'px';
}

function _ieInsert(text){
  const ta = _ieTA; if(!ta) return;
  const s = ta.selectionStart ?? ta.value.length;
  const e = ta.selectionEnd ?? s;
  ta.value = ta.value.slice(0,s) + text + ta.value.slice(e);
  ta.selectionStart = ta.selectionEnd = s + text.length;
  _ieAutosize();
}

function _ieInsertMarkup(t){
  const ta = _ieTA; if(!ta) return;
  const s = ta.selectionStart ?? 0;
  const e = ta.selectionEnd ?? s;
  let content = '';
  if (s !== e){
    content = ta.value.slice(s,e);
  } else {
    const v = prompt(`${t.toUpperCase()} text:`, '');
    if(v===null) return;
    content = v;
  }
  const insertText = `${t}${content}.`;
  ta.value = ta.value.slice(0,s) + insertText + ta.value.slice(e);
  const pos = s + insertText.length;
  ta.selectionStart = ta.selectionEnd = pos;
  _ieAutosize();
}

function _ieOpen(r, c, seed){
  ensureInlineEditor();
  _ieCell = { r, c };
  const cell = state.rows[r][c];

  // Seed value = existing markups (as â€œkA. gB. â€¦â€) + text
  const prefix = (cell.markups||[]).map(m => (m.t||'') + (m.v||'') + '.').join(' ');
  const initial = (seed!==undefined ? seed : (prefix + (prefix && cell.text ? ' ' : '') + (cell.text || '')));

  _ieTA.value = initial;
  _ieAutosize();

  // position: fixed near the cell
  const tbl = document.getElementById('grid');
  const td = tbl?.rows?.[r]?.cells?.[c];
  if(td){
    const rect = td.getBoundingClientRect();
    const host = _ieEl;
    // show to measure
    host.style.visibility='hidden';
    host.classList.add('show');
    const w = host.offsetWidth || 360;
    const h = host.offsetHeight || 80;
    host.classList.remove('show');
    host.style.visibility='';

    // prefer top if space allows
    const margin = 8;
    const preferTop = rect.top > h + 24;
    const top = preferTop ? rect.top - h - margin : rect.bottom + margin;
    const left = Math.min(Math.max(6, rect.left), window.innerWidth - w - 6);

    host.style.top = `${top}px`;
    host.style.left = `${left}px`;
    host.classList.add('show');
  }

  // hide floating tools while editing
  hideCellTools?.();

  // focus
  setTimeout(()=> _ieTA.focus(), 0);
}

function _ieSave(){
  if(!_ieCell) return _ieClose(false);
  const {r,c} = _ieCell;
  const cell = state.rows[r][c];
  const parsed = parseCell('; ' + _ieTA.value);
  cell.markups = parsed.markups || [];
  cell.text    = parsed.text || '';
  _ieClose(true);
  // re-render + keep selection + show tools again
    withGridScrollRestored(()=>{
  renderGrid(); syncExportNote();
  });
  selectCell(r,c);
}

function _ieClose(_saved){
  if(_ieEl) _ieEl.classList.remove('show');
  _ieCell = null;
}

// Public entrypoints (replace your old inline editors with these)
function startInlineEdit(td, r, c, seedKey){
  _ieOpen(r, c, seedKey);
}
function startInlineEditFast(td, r, c, seedKey){
  _ieOpen(r, c, seedKey);
}
// expose overlay starters
window.__openOverlayEditor = (r,c,seed) => _ieOpen(r,c,seed);


</script>
<script>
// Lightweight extras: type-to-edit + add/remove rows/cols (no MutationObserver)
(function(){
  // Type-to-edit & enter-to-open editor
  window.addEventListener('keydown', (e)=>{
    const active = document.activeElement;
    if(active && ['INPUT','TEXTAREA'].includes(active.tagName)) return;
    if(!state || state.sel.r==null) return;

    const tbl = document.getElementById('grid');
    const row = tbl?.rows[state.sel.r];
    const cell = row?.cells[state.sel.c];
    if(!cell) return;

    if(e.key.length===1 && !e.metaKey && !e.ctrlKey && !e.altKey){
      // start editing with initial char
      if(typeof window.__openOverlayEditor === 'function') window.__openOverlayEditor(state.sel.r, state.sel.c, e.key);
    } else if(e.key==='Enter'){
      if(typeof window.__openOverlayEditor === 'function') window.__openOverlayEditor(state.sel.r, state.sel.c);
    }
  });

  // Toolbar for rows/cols
  function ensureTools(){
    const grid = document.getElementById('grid');
    const gridWrap = grid && grid.parentElement; if(!gridWrap) return;
    if(document.getElementById('gridTools')) return;
    const tools = document.createElement('div');
    tools.className='toolbar'; tools.id='gridTools';
    tools.innerHTML = `
      <button id="__addRowAbove">ì• ì—´ì°¨ ì¶”ê°€</button>
      <button id="__addRowBelow">ë’¤ ì—´ì°¨ ì¶”ê°€</button>
      <button id="__delRow">ì—´ì°¨ ì‚­ì œ</button>
      <span style="width:6px"></span>
      <button id="__addColLeft">ì• ì—­ ì¶”ê°€</button>
      <button id="__addColRight">ë’¤ ì—­ ì¶”ê°€</button>
      <button id="__delCol">ì—­ ì‚­ì œ</button>
      <span style="width:6px"></span>
      <button id="__appendRow">ë§¨ ë’¤ì— ì—´ì°¨ ì¶”ê°€</button>
      <button id="__appendCol">ë§¨ ë’¤ì— ì—­ ì¶”ê°€</button>`;
    gridWrap.parentElement.insertBefore(tools, gridWrap);

    const addRow = (i)=>{ const cols = state.rows[0]?.length || 1; const row = Array.from({length:cols}, ()=> parseCell('')); state.rows.splice(i,0,row); };
    const delRow = (i)=>{ if(i>=0 && i<state.rows.length) state.rows.splice(i,1); };
    const addCol = (i)=>{ state.rows.forEach(r=> r.splice(i,0, parseCell(''))); };
    const delCol = (i)=>{ state.rows.forEach(r=>{ if(i>=0 && i<r.length) r.splice(i,1); }); };

    const click = (id, fn)=>{ const b=document.getElementById(id); if(!b) return; b.addEventListener('click', ()=>{ const {r,c}=state.sel; fn(r,c); renderGrid(); }); };

    click('__addRowAbove', (r)=> addRow(Math.max(0,r)) );
    click('__addRowBelow', (r)=> addRow(Math.max(0,r+1)) );
    click('__delRow', (r)=> { delRow(r); state.sel.r=Math.min(r, state.rows.length-1); });
    click('__addColLeft',  (r,c)=> addCol(Math.max(0,c)) );
    click('__addColRight', (r,c)=> addCol(Math.max(0,c+1)) );
    click('__delCol',      (r,c)=> { delCol(c); state.sel.c=Math.min(c,(state.rows[0]?.length||1)-1); });
    click('__appendRow',   ()=> { addRow(state.rows.length); state.sel.r=state.rows.length-1; });
    click('__appendCol',   ()=> { addCol((state.rows[0]?.length||0)); state.sel.c=(state.rows[0]?.length||1)-1; });
  }
  ensureTools();
})();

</script>
<script>

// âš¡ Performance overlay: async CSV parsing (Web Worker) + chunked rendering + non-blocking edits
(function(){
  const tbl = document.getElementById('grid');
  const statusEl = document.getElementById('status');
  const parseBtn = document.getElementById('parseBtn');

  // 1) Build a tiny worker for CSV parsing so the UI won't freeze
  const workerSrc = `self.onmessage = (e)=>{\n  const text = e.data.text||'';\n  const lines = text.split(/\\r?\\n/).filter(l=>l.trim().length>0);\n  const rows = new Array(lines.length);\n  for(let i=0;i<lines.length;i++){\n    const line = lines[i];\n    const cells = line.split(/,(?=(?:[^']*'[^']*')*[^']*$)/).map(s=> s.trim());\n    rows[i] = cells;\n    if(i%500===0) postMessage({type:'progress', done:i, total:lines.length});\n  }\n  postMessage({type:'done', rows});\n}`;
  const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], {type:'application/javascript'})));

  function setStatus(t){ if(!statusEl) return; statusEl.textContent=t; if(!t) return; }

  // Swap the old Parse button to remove previous listeners
  if(parseBtn){
    const clone = parseBtn.cloneNode(true);
    parseBtn.parentNode.replaceChild(clone, parseBtn);
    clone.addEventListener('click', ()=>{
      const input = document.getElementById('csvIn').value;
      setStatus('ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
      worker.postMessage({text: input});
    });
  }

  worker.onmessage = (e)=>{
    const {type} = e.data;
    if(type==='progress'){
      const {done,total} = e.data; setStatus(`ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘... ${Math.floor(done/Math.max(1,total)*100)}%`);
    } else if(type==='done'){
      setStatus('í¸ì§‘ê¸° ë¡œë”© ì¤‘...');
      const rawRows = e.data.rows;
      state.rows = rawRows.map(r => r.map(raw => parseCell(raw)));
      chunkedRender(state.rows);
      state.sel = {r:0,c:0};
      syncExportNote();
      buildCellTools(0,0);
positionCellTools(0,0);
      setStatus('');
    }
  };

  // 2) Chunked rendering with requestAnimationFrame
  function chunkedRender(rows){
     const tbl = document.getElementById('grid');
    withGridScrollRestored(()=>{
    tbl.innerHTML = ''; // clear
  });
    const total = rows.length;
    const CHUNK = 150; // rows per frame
    let i = 0;
    function frame(){
      const frag = document.createDocumentFragment();
      for(let k=0; k<CHUNK && i<total; k++, i++){
        frag.appendChild(buildRow(rows[i], i));
      }
      tbl.appendChild(frag);
      if(i<total){ requestAnimationFrame(frame); }
    }
    requestAnimationFrame(frame);
  }

  function buildRow(row, ri){
    const tr = document.createElement('tr');
    row.forEach((cell,ci)=>{
      const td = document.createElement(ri<2? 'th':'td');
      td.className = 'cell' + (cell.ops.header? ' headerCell':'' );
      if(cell.ops.colBorder) td.classList.add('colBorderCell');
      if(cell.ops.colNoBorder) td.classList.add('colNoBorderCell');
      if (cell.ops.removed) {
  td.classList.add('removedCell');
}

const div = document.createElement('div');
div.innerHTML = renderMarkupHTML(cell) || '&nbsp;';
div.style.whiteSpace = 'pre-wrap';
td.appendChild(div);
const chips = document.createElement('div');
chips.className='chips';
renderChipsInto(chips, ri, ci);
td.appendChild(chips);
      td.addEventListener('click',()=> selectCellFast(ri,ci));
      td.addEventListener('dblclick',()=> window.__openOverlayEditor(ri, ci));
      tr.appendChild(td);
    });
    return tr;
  }

  function displayTextFast(cell){
    let t = cell.text || cell.markups.map(m=>m.v).filter(Boolean).join(' ');
    if(!t && cell.markups.some(m=>m.v)) t = cell.markups.map(m=>m.v).join(' ');
    return (t || cellToString(cell) || '').replaceAll('/', '\n');
  }

  function selectCellFast(r,c){
    const prev = state.sel || {}; const tblRows = tbl.rows;
    if(prev.r!=null && tblRows[prev.r] && tblRows[prev.r].cells[prev.c]){
      const el = tblRows[prev.r].cells[prev.c]; el.style.outline='none'; el.style.outlineOffset='';
    }
    state.sel={r,c};
    const cur = tblRows[r]?.cells[c];
    if(cur){ cur.style.outline='2px solid var(--accent)'; cur.style.outlineOffset='-2px'; }
    buildCellTools(r,c);
positionCellTools(r,c);

  }

function startInlineEditFast(td, r, c, seedKey){
  const cell = state.rows[r][c];
  const prefix = (cell.markups||[]).map(m => (m.t || '') + (m.v || '') + '.').join(' ');
  const seed = (seedKey!==undefined ? seedKey : '') ||
               (prefix + (prefix && cell.text ? ' ' : '') + (cell.text || ''));

  const ta = document.createElement('textarea');
  ta.value = seed;
  ta.rows = 1;
  const auto = ()=>{ ta.style.height='auto'; ta.style.height=(ta.scrollHeight)+"px"; };
  const first = td.firstChild; const chips = td.lastChild;
  td.insertBefore(ta, first);
  if(first) first.remove();
  ta.focus(); auto();
  ta.addEventListener('input', auto);
  ta.addEventListener('keydown', e=>{
    if(e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      const {selectionStart:s, selectionEnd:ePos, value:v} = ta;
      ta.value = v.slice(0,s) + '/' + v.slice(ePos);
      ta.selectionStart = ta.selectionEnd = s+1; auto();
    }
    if(e.key==='Escape'){ cancel(); }
  });
  ta.addEventListener('blur', save);

  function save(){
    const parsed = parseCell('; ' + ta.value);
    cell.markups = parsed.markups || [];
    cell.text = parsed.text || '';
    const div=document.createElement('div');
    div.className='content';
    div.innerHTML = renderMarkupHTML(cell) || '&nbsp;';
    div.style.whiteSpace='pre-wrap';
    td.insertBefore(div, chips);
    ta.remove();
  }
  function cancel(){
    const div=document.createElement('div');
    div.className='content';
    div.innerHTML = renderMarkupHTML(cell) || '&nbsp;';
    div.style.whiteSpace='pre-wrap';
    td.insertBefore(div, chips);
    ta.remove();
  }
}

  // Expose overrides and helpers for tests
  window.renderGrid = ()=> chunkedRender(state.rows);
  window.startInlineEdit = startInlineEditFast;
  window.selectCell = selectCellFast;
  window.displayTextFast = displayTextFast;
})();
</script>
    <div class="footer" style="padding-bottom:30px;"></div>
</body>
</html>
